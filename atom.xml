<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>edgeowner</title>
  
  <subtitle>多读书，读好书，少写bug</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://edgeowner.com/"/>
  <updated>2018-03-14T02:28:55.234Z</updated>
  <id>http://edgeowner.com/</id>
  
  <author>
    <name>ZhangSunny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java序列化</title>
    <link href="http://edgeowner.com/2018/03/13/Java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://edgeowner.com/2018/03/13/Java序列化/</id>
    <published>2018-03-13T12:06:04.000Z</published>
    <updated>2018-03-14T02:28:55.234Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java" scheme="http://edgeowner.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
      <category term="Serialize" scheme="http://edgeowner.com/tags/Serialize/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO</title>
    <link href="http://edgeowner.com/2018/03/13/Java-NIO/"/>
    <id>http://edgeowner.com/2018/03/13/Java-NIO/</id>
    <published>2018-03-13T12:05:28.000Z</published>
    <updated>2018-03-14T02:35:31.573Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java LDAP</title>
    <link href="http://edgeowner.com/2018/03/13/Java-LDAP/"/>
    <id>http://edgeowner.com/2018/03/13/Java-LDAP/</id>
    <published>2018-03-13T12:05:05.000Z</published>
    <updated>2018-03-14T02:35:23.955Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java CAS</title>
    <link href="http://edgeowner.com/2018/03/13/Java-CAS/"/>
    <id>http://edgeowner.com/2018/03/13/Java-CAS/</id>
    <published>2018-03-13T12:04:50.000Z</published>
    <updated>2018-03-19T10:37:03.986Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java面试题目集锦 (1)</title>
    <link href="http://edgeowner.com/2016/06/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E9%9B%86%E9%94%A6/"/>
    <id>http://edgeowner.com/2016/06/01/Java面试题目集锦/</id>
    <published>2016-06-01T12:21:37.000Z</published>
    <updated>2018-03-14T02:35:47.142Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java面试题目汇总" scheme="http://edgeowner.com/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
      <category term="面试题" scheme="http://edgeowner.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(3)</title>
    <link href="http://edgeowner.com/2016/04/26/JVM3/"/>
    <id>http://edgeowner.com/2016/04/26/JVM3/</id>
    <published>2016-04-26T10:00:00.000Z</published>
    <updated>2018-03-21T12:53:02.233Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JVM具体参数和内存区域映射图例"><a href="#JVM具体参数和内存区域映射图例" class="headerlink" title="JVM具体参数和内存区域映射图例"></a>JVM具体参数和内存区域映射图例</h4><p> &emsp;&emsp;此文主要用图例方式描绘了JVM的结构，介绍了JVM内存结构对应的参数名。</p><ul><li>在具体实现上，JVM将需要进行垃圾回收的区域分为3类：新生代（Young Generation）、老年代(Old Generation)、永久代(Permanent Generation)。其中新生代又分为eden和survival（S0、S1），具体结构如下图所示：</li><li><img src="http://p5vswdxl9.bkt.clouddn.com/jvm_and_params_map.png" alt="图示1.0"><a id="more"></a></li><li>简单讲，新生代的eden、新生代的survival、老生代里的对象存活时间依次变长。</li></ul><table><thead><tr><th style="text-align:left"><strong>参数名称</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td style="text-align:left">-Xmx</td><td>初始堆大小</td></tr><tr><td style="text-align:left">-Xms</td><td>最大堆大小</td></tr><tr><td style="text-align:left">-Xss</td><td>每个线程的堆栈大小</td></tr><tr><td style="text-align:left">-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td></tr><tr><td style="text-align:left">-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td></tr><tr><td style="text-align:left">-XX:PermSize</td><td>设置持久代(perm gen)初始值</td></tr><tr><td style="text-align:left">-XX:MaxPermSize</td><td>设置持久代最大值</td></tr><tr><td style="text-align:left">-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td></tr><tr><td style="text-align:left">-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td></tr></tbody></table><hr><h4 id="JVM内存结构图例"><a href="#JVM内存结构图例" class="headerlink" title="JVM内存结构图例"></a>JVM内存结构图例</h4><p><img src="http://p5vswdxl9.bkt.clouddn.com/JVM_Flow.jpg" alt=""><br>   &emsp;&emsp;方法区和堆是所有<strong>线程共享的内存区域</strong>；而java栈、本地方法栈和程序计数器是运行是<strong>线程私有的内存区域</strong>。</p><ul><li><p>Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p></li><li><p>方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li><li><p>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p></li><li><p>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p></li><li><p>ClassLoader是负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p>Native Interface是负责调用本地接口的。他的作用是调用不同语言的接口给JAVA用，他会在Native Method Stack中记录对应的本地方法，然后调用该方法时就通过Execution Engine加载对应的本地lib。原本多于用一些专业领域，如JAVA驱动，地图制作引擎等，现在关于这种本地方法接口的调用已经被类似于Socket通信，WebService等方式取代。</p></li><li><p>Execution Engine是执行引擎，也叫Interpreter。Class文件被加载后，会把指令和数据信息放入内存中，Execution Engine则负责把这些命令解释给操作系统。</p></li><li><p>Runtime Data Area则是存放数据的，分为五部分：Stack，Heap，Method Area，PC Register，Native Method Stack。几乎所有的关于java内存方面的问题，都是集中在这块。下图是javapapers.com上关于Run-time Data Areas的描述：<img src="http://p5vswdxl9.bkt.clouddn.com/JVM_2.jpg" alt=""></p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JVM具体参数和内存区域映射图例&quot;&gt;&lt;a href=&quot;#JVM具体参数和内存区域映射图例&quot; class=&quot;headerlink&quot; title=&quot;JVM具体参数和内存区域映射图例&quot;&gt;&lt;/a&gt;JVM具体参数和内存区域映射图例&lt;/h4&gt;&lt;p&gt; &amp;emsp;&amp;emsp;此文主要用图例方式描绘了JVM的结构，介绍了JVM内存结构对应的参数名。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在具体实现上，JVM将需要进行垃圾回收的区域分为3类：新生代（Young Generation）、老年代(Old Generation)、永久代(Permanent Generation)。其中新生代又分为eden和survival（S0、S1），具体结构如下图所示：&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://p5vswdxl9.bkt.clouddn.com/jvm_and_params_map.png&quot; alt=&quot;图示1.0&quot;&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(2)</title>
    <link href="http://edgeowner.com/2016/04/24/jvm2/"/>
    <id>http://edgeowner.com/2016/04/24/jvm2/</id>
    <published>2016-04-24T12:00:00.000Z</published>
    <updated>2018-03-21T09:28:22.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存结构（运行时数据区）"><a href="#JVM内存结构（运行时数据区）" class="headerlink" title="JVM内存结构（运行时数据区）"></a>JVM内存结构（运行时数据区）</h3><p>该文承接<strong><a href="http://edgeowner.com/2016/04/19/jvm/">JVM内存结构简介(1)</a></strong>博文主要介绍所有<code>线程共享的区域</code>(<strong><em>方法区 </em></strong>和<strong><em>堆</em></strong>))，本文简单介绍剩余JVM的是三个区域：<code>Java栈(Java Stack)</code>、<code>本地方法栈(Native Method Stack)</code>、<code>程序计数器(Program Counter Register)</code>。</p><a id="more"></a><hr><h4 id="三、Java虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#三、Java虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="三、Java虚拟机栈(Java Virtual Machine Stacks)"></a>三、Java虚拟机栈(Java Virtual Machine Stacks)</h4><ol><li><strong>作用</strong>：描述的就是Java方法执行的内存模型。每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储<code>局部变量表</code>、<code>操作栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈道出栈的过程。一个方法的执行过程就等同于栈帧进栈出栈的过程。</li><li><strong>特点</strong>：线程私有的，生命周期和线程相同。栈是一个后进先出(<strong>LIFO</strong>)的数据结构，每次方法调用时，一个新的栈帧创建并被压栈到栈顶， 当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。除了栈帧的压栈和出栈，栈不能被直接操作。 在JVM中，若线程请求栈的深度 超过了虚拟机允许的最大深度 ，则会抛出StackOverflowError异常；当栈进行动态扩展，但 无法申请到相应内存空间（此时，线程请求的栈深度未超过虚拟机允许的最大深度）时，则会抛出OutOfMemoryError异常。</li><li><code>局部变量表</code>：存放了编译期间可以知道大小的各种类型变量，它所需要的内存空间大小在编译期间就已经分配，当一个方法被调用时，栈帧进入虚拟机栈，在运行期间，局部变量表大小是不会变化的。</li><li><code>栈帧(Frame)</code>：<strong><em>栈帧只存储指向堆中对象或数组的引用 </em></strong>，包含<code>局部变量数组</code>、<code>返回值</code>、<code>操作数栈</code>、<code>类当前方法运行时常量池引用</code>：  <blockquote><p><code>局部变量数组</code>：包含了方法执行过程中所有变量，包括this引用、所有方法参数、其他局部变量。对于类方法（也就是静态方法），方法参数从下标 0 开始，对于对象方法，位置0保留为 this。（boolean、byte、char、long、short、int、float、double、reference、returnAddress均为局部变量，除了 long 和 double 类型以外，所有的变量类型都占用局部变量数组的一个位置。long 和 double 需要占用局部变量数组两个连续的位置，因为它们是 64 位双精度，其它类型都是 32 位单精度。）<br><code>操作数栈</code>：在执行字节码指令过程中被用到，这种方式类似于原生<strong>CPU寄存器</strong>。大部分JVM字节码把时间花费在操作数栈的操作上：<strong><em>入栈 </em></strong>、<strong><em>出栈 </em></strong> 、<strong><em>复制 </em></strong> 、<strong><em>交换 </em></strong>、<strong><em>产生消费变量 </em></strong>的操作。因此，局部变量数组和操作数栈之间的交换变量指令操作通过字节码频繁执行。比如，一个简单的变量初始化语句将产生两条跟操作数栈交互的字节码。</p><p>关于局部变量数组、操作数栈和运行时常量池之间交互的详细信息，可以在类文件结构部分找到。</p></blockquote></li></ol><hr><h4 id="四、本地方法栈-Native-Method-Stack"><a href="#四、本地方法栈-Native-Method-Stack" class="headerlink" title="四、本地方法栈(Native Method Stack)"></a>四、本地方法栈(Native Method Stack)</h4><ol><li><strong>作用</strong>：Java虚拟机在实现时，可以根据自身需求，确定是否实现本地方法栈。在实现上，JVM可能会使用到传统的栈（通常称之为“C Stacks”）来支持 native 方法（指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈。当JVM支持本地方法栈时，这个栈会在线程创建时按照线程分配。 在JVM中，本地方法栈可能发生的异常情况也分为Stack OverflowError和OutOfMemoryError异常，出错原因和虚拟机栈相似，此处不再赘述。</li><li><strong>特点</strong>：Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。本地方法栈则是为虚拟机使用到的Native方法服务.</li></ol><hr><h4 id="五、程序计数器-Program-Counter-Register"><a href="#五、程序计数器-Program-Counter-Register" class="headerlink" title="五、程序计数器(Program Counter Register)"></a>五、程序计数器(Program Counter Register)</h4><ul><li>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li><strong><em>在任意时刻，一个Java虚拟机线程只会执行一个方法，而 PC Java 虚拟机允许多条线程同时执行。因此，每一条 Java虚拟机线程都有自己的 PC 寄存器 ，他们是相互独立的。每一条 Java虚拟机线程都有自己的PC 寄存器，他们是相互独立的。 </em></strong></li><li>我们称正在被线程执行的方法称为该线程的当前方法（Current Method）。如果这个方法不是 native 的，那 PC 寄存器就保存 Java 虚拟机正在执行的字节码指令的地址，如果该方法是 native 的，那 PC 寄存器的值是 undefined。</li><li>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</li><li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;a href=&quot;#JVM内存结构（运行时数据区）&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;/a&gt;JVM内存结构（运行时数据区）&lt;/h3&gt;&lt;p&gt;该文承接&lt;strong&gt;&lt;a href=&quot;http://edgeowner.com/2016/04/19/jvm/&quot;&gt;JVM内存结构简介(1)&lt;/a&gt;&lt;/strong&gt;博文主要介绍所有&lt;code&gt;线程共享的区域&lt;/code&gt;(&lt;strong&gt;&lt;em&gt;方法区 &lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;堆&lt;/em&gt;&lt;/strong&gt;))，本文简单介绍剩余JVM的是三个区域：&lt;code&gt;Java栈(Java Stack)&lt;/code&gt;、&lt;code&gt;本地方法栈(Native Method Stack)&lt;/code&gt;、&lt;code&gt;程序计数器(Program Counter Register)&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(1)</title>
    <link href="http://edgeowner.com/2016/04/19/jvm/"/>
    <id>http://edgeowner.com/2016/04/19/jvm/</id>
    <published>2016-04-19T10:35:25.000Z</published>
    <updated>2018-03-21T09:42:18.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存结构（运行时数据区）"><a href="#JVM内存结构（运行时数据区）" class="headerlink" title="JVM内存结构（运行时数据区）"></a>JVM内存结构（运行时数据区）</h3><p>JVM内存结构指得是：运行时数据区（Runtime Data Area），由 <strong><em>方法区(Method Area) </em></strong>、<strong><em>堆(Heap) </em></strong>、<strong><em>Java栈(Java Stack) </em></strong>、<strong><em>本地方法栈(Native Method Stack)</em></strong>、<strong><em>程序计数器(Program Counter Register)</em></strong>。<br><img src="http://p5vswdxl9.bkt.clouddn.com/JVMRuntime" alt=""></p><a id="more"></a><hr><h4 id="一、方法区-Method-Area"><a href="#一、方法区-Method-Area" class="headerlink" title="一、方法区(Method Area)"></a>一、方法区(Method Area)</h4><ol><li><strong>作用</strong>： 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。此区域内存回收目标主要针对常量池回收和对类型的卸载回收。 </li><li><strong>特点</strong>：线程共享 。</li><li><strong>永久代的疑问(PerGen)</strong>：该内存区域一般被称为”<em><strong>永久代(Permanent Generation)</strong></em> “，二者并不等价，设计之初就把GC分代收集扩展至方法区，或者说使用永久代实现方法区而已。</li><li><strong>运行时常量池</strong>：方法区的一部分，存放<strong><em>编译期</em></strong>生成的<strong>各种字面量</strong>(“zdy”,”123”等)和 <strong>符号引用</strong> 。编译器和运行期的intern()都可以将常量放入池中。受方法区限制，常量池无法申请到内存时会抛出OutOfMemoryError异常。运行时常量池具有动态性，并非只有Class文件中的内容才能进入运行时常量池，<strong><em>运行期间</em></strong>也能将新的常量放入池中。如String.intern（）方法。</li><li><strong>方法区储存类的信息</strong>： <ol><li><code>Classloader引用</code>；</li><li><code>运行时常量池</code>：数值型常量、字段引用、方法引用、属   性；  </li><li><code>字段数据</code>：针对每个字段的信息、字段名、类型、修饰符、属性；</li><li><code>方法数据</code>：每个方法、方法名、返回值类型、参数类型、修饰符、属性；</li><li><code>方法代码</code>：每个方法、字节码、操作数栈大小、局部变量大小、局部变量表、异常表、每个异常处理器、开始点、结束点、异常处理代码的程序计数器偏移量、被捕获异常类对应的常量池下标；</li></ol></li></ol><ul><li><strong><em> 字面量(literal) </em></strong>：由字母，数字等构成的字符串或者数值，用于表达源代码中一个固定值的表示法(notation)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。</li><li><strong><em> 符号引用 </em></strong>：简单地说就是，符号引用存在class文件中的常量池，包括类和接口的全限定名、字段的名称和描述符以及方法的名称和描述符。jvm加载class的时候就可以凭着这三者进行动态连接，得到具体的内存地址。占用的数据结构在常量池项目类型有，例如类或接口的符号引用结构为u1的tag和u2的name_index。</li></ul><hr><h4 id="二、堆-Heap"><a href="#二、堆-Heap" class="headerlink" title="二、堆(Heap)"></a>二、堆(Heap)</h4><ol><li><strong> 作用 </strong>：被所有线程运行时共享的内存区域，JVM启动之后，存放对象实例和数组，内部会划出多个线程私有的分配缓冲区(Thread Location Allocation Buffer ,<strong>TLAB</strong>)。该存储区域物理上可以是不连续空间，但是逻辑上一定要连续。</li><li><strong> 特点 </strong>：是GC管理的主要区域，由于GC（垃圾收集器）是采用分代收集算法,根据对象存活率，堆还可以分为<strong>新生代</strong>、<strong>老年代</strong>、<strong>永久代</strong>。</li><li><p><strong> 分类 </strong>：</p><blockquote><p><em><strong>新生代(Young Generation)</strong></em> ：方法中去new一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象。 每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后清理Eden和刚才用过的Survivor空间。<strong><em> HotSpot虚拟机默认Eden和Survivor的大小比例是8:1 </em></strong>，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。 98%的对象可回收只是一般场景下的数据，没办法保证每次回收都只有不多于10%的对象存活，当Survivor不够用时，需要依赖于老年代进行分配担保，所以<strong><em> 大对象 </em></strong>直接进入老年代。同时长期存活的对象进入老年代（虚拟机给每个对象定义一个年龄计数器）。<br><code>年轻代内存又被分成三部分</code>：  </p><ol><li><code>Eden空间</code>：对象优先分配在Eden区，若Eden区无足够的空间，虚拟机执行一次Minor GC。对象被创建时首先放到这个区域，进行垃圾回收后，不能被回收的对象被放到空的Survivor区域。</li><li><code>Survivor Space幸存者区</code>：用于保存在Eden Space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两类，分别为<strong><em>To Suvivor </em></strong> 和 <strong><em>From Suvivor</em></strong>两个区域，这两个区域空间大小是一样的执行：<br>   &emsp;&emsp;a.<code>From Survivor空间</code>：<br>   &emsp;&emsp;b.<code>To Survivor空间</code> ：      </li><li><code>执行回收的内存运行</code>： 执行垃圾回收时Eden区域不能被回收的对象被放入到空的Suvivor(也就是<strong>To Survivor</strong>，同时Eden区域的内存会在垃圾回收的过程中全部释放)，另一个Survivor(即From Survivor)里不能被回收的对象也会被放入到Survivor(即To Survivor)，然后To Survivor和 From Survivor的标记会互换，始终保证一个Survivor是空的。 </li></ol></blockquote><blockquote><p><em><strong>老年代(Old Generation)</strong></em> ：<strong> 老年代空间大小&emsp;=&emsp;堆空间大小&emsp;–&emsp;年轻代大空间大小 </strong>   </p></blockquote></li><li><p><strong> 年轻代的垃圾回收 </strong>：<strong><em>Eden Space(伊甸园) </em></strong>和<strong><em>Suvivor Space </em></strong>都属于新生代，新生代中执行垃圾回收被称为Minor GC(由于是对新生代进行垃圾回收，所以被称为Young GC)，每次Young GC 后留下来的对象age +1。</p><blockquote><p><em><strong> Eden:From:TO =8:1:1</strong></em><br> 由于新生代中90%的对象都是”朝生夕死”，采用复制算法是比较合理的，首先只移动了存活下来的对象(比较少数),其次内存在移动到To区域后是有顺序的，不存在内存碎片。值得一提的是，假如在一次Minor GC时,<code>Eden中存活的对象</code>+<code>From中存活的对象</code>&gt;<code>To的剩余空间</code>，则会通过担保机制将对象直接转移到Old Gen ,如果Old Gen的内存空间也不够，则进行一次Full GC .当<strong><em> 对象的年龄到达15岁时会转移到Old Gen(可通过参数配置，一般不建议更改) </em></strong></p></blockquote></li><li><p><strong> 使用方式 </strong>：Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。<strong><em> 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 </em></strong></p></li><li><code>对象分配规则</code>：<br> <code>1.对象优先分配在Eden区</code>：若Eden区没有足够的空间时，虚拟机执行一次Minor GC；<br> <code>2.大对象(大对象是指需要大量连续内存空间的对象)直接进入老年代</code>：这样做目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝(新生代采用 <strong><em>复制算法 </em></strong> 收集内存)；<br> <code>3.长期存活的对象进入老年代</code>：虚拟机为每个对象定义一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象年龄加 1，直到达到阀值，对象进入老年区；<br> <code>4.动态判断对象的年龄</code>：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代；<br> <code>5.空间分配担保</code>：每次每次进行Minor GC时，JVM会计算Survivor区移至<strong>老年区的对象</strong>的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC，如果false则进行Full GC；    </li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;a href=&quot;#JVM内存结构（运行时数据区）&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;/a&gt;JVM内存结构（运行时数据区）&lt;/h3&gt;&lt;p&gt;JVM内存结构指得是：运行时数据区（Runtime Data Area），由 &lt;strong&gt;&lt;em&gt;方法区(Method Area) &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;堆(Heap) &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;Java栈(Java Stack) &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;本地方法栈(Native Method Stack)&lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;程序计数器(Program Counter Register)&lt;/em&gt;&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;http://p5vswdxl9.bkt.clouddn.com/JVMRuntime&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程(Chapter1)</title>
    <link href="http://edgeowner.com/2015/05/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://edgeowner.com/2015/05/13/Java多线程/</id>
    <published>2015-05-13T12:15:25.000Z</published>
    <updated>2018-03-14T02:35:55.291Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java Multi-thread Programming" scheme="http://edgeowner.com/categories/Java-Multi-thread-Programming/"/>
    
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://edgeowner.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaCore（Java核心）</title>
    <link href="http://edgeowner.com/2015/04/13/Java-Core/"/>
    <id>http://edgeowner.com/2015/04/13/Java-Core/</id>
    <published>2015-04-13T11:06:43.000Z</published>
    <updated>2018-03-14T02:35:08.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java核心"><a href="#Java核心" class="headerlink" title="Java核心"></a>Java核心</h2><h4 id="Java基本语法："><a href="#Java基本语法：" class="headerlink" title="Java基本语法："></a>Java基本语法：</h4><h4 id="Java类和对象："><a href="#Java类和对象：" class="headerlink" title="Java类和对象："></a>Java类和对象：</h4><h4 id="Java集合："><a href="#Java集合：" class="headerlink" title="Java集合："></a>Java集合：</h4><h4 id="Java泛型："><a href="#Java泛型：" class="headerlink" title="Java泛型："></a>Java泛型：</h4><h4 id="Java注解："><a href="#Java注解：" class="headerlink" title="Java注解："></a>Java注解：</h4><h4 id="Java反射："><a href="#Java反射：" class="headerlink" title="Java反射："></a>Java反射：</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java核心&quot;&gt;&lt;a href=&quot;#Java核心&quot; class=&quot;headerlink&quot; title=&quot;Java核心&quot;&gt;&lt;/a&gt;Java核心&lt;/h2&gt;&lt;h4 id=&quot;Java基本语法：&quot;&gt;&lt;a href=&quot;#Java基本语法：&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Java" scheme="http://edgeowner.com/categories/Java/"/>
    
    
      <category term="javacore" scheme="http://edgeowner.com/tags/javacore/"/>
    
  </entry>
  
  <entry>
    <title>博客简介</title>
    <link href="http://edgeowner.com/2014/08/13/first/"/>
    <id>http://edgeowner.com/2014/08/13/first/</id>
    <published>2014-08-13T08:47:00.000Z</published>
    <updated>2018-03-14T04:40:59.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ZhangSunny的First-Blog"><a href="#ZhangSunny的First-Blog" class="headerlink" title="ZhangSunny的First Blog"></a>ZhangSunny的First Blog</h1><h3 id="个人博客简介"><a href="#个人博客简介" class="headerlink" title="个人博客简介"></a>个人博客简介</h3><p>   &emsp;&emsp;&emsp;&emsp;作为一枚计科专业的码农，2014年开始从事后端应用开发至今，将日常工作中遇到的问题、个人知识积累、个人见解和“打怪升级”晋级的经验分享于自己的博客，欢迎广大蜀黍来此博客分享自己的“故事”。</p><p>   &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——&emsp;ZhangSunny </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ZhangSunny的First-Blog&quot;&gt;&lt;a href=&quot;#ZhangSunny的First-Blog&quot; class=&quot;headerlink&quot; title=&quot;ZhangSunny的First Blog&quot;&gt;&lt;/a&gt;ZhangSunny的First Blog&lt;/
      
    
    </summary>
    
      <category term="随笔" scheme="http://edgeowner.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="小记" scheme="http://edgeowner.com/tags/%E5%B0%8F%E8%AE%B0/"/>
    
  </entry>
  
</feed>
