<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>edgeowner</title>
  
  <subtitle>多读书，读好书，少写bug</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://edgeowner.com/"/>
  <updated>2018-04-03T03:17:34.243Z</updated>
  <id>http://edgeowner.com/</id>
  
  <author>
    <name>ZhangSunny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo搭建指南（一）</title>
    <link href="http://edgeowner.com/2018/04/03/Hexo/"/>
    <id>http://edgeowner.com/2018/04/03/Hexo/</id>
    <published>2018-04-03T03:16:57.000Z</published>
    <updated>2018-04-03T03:17:34.243Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java序列化</title>
    <link href="http://edgeowner.com/2018/03/13/Java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://edgeowner.com/2018/03/13/Java序列化/</id>
    <published>2018-03-13T12:06:04.000Z</published>
    <updated>2018-03-14T02:28:55.234Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java" scheme="http://edgeowner.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
      <category term="Serialize" scheme="http://edgeowner.com/tags/Serialize/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO</title>
    <link href="http://edgeowner.com/2018/03/13/Java-NIO/"/>
    <id>http://edgeowner.com/2018/03/13/Java-NIO/</id>
    <published>2018-03-13T12:05:28.000Z</published>
    <updated>2018-03-14T02:35:31.573Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java LDAP</title>
    <link href="http://edgeowner.com/2018/03/13/Java-LDAP/"/>
    <id>http://edgeowner.com/2018/03/13/Java-LDAP/</id>
    <published>2018-03-13T12:05:05.000Z</published>
    <updated>2018-03-14T02:35:23.955Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java CAS</title>
    <link href="http://edgeowner.com/2018/03/13/Java-CAS/"/>
    <id>http://edgeowner.com/2018/03/13/Java-CAS/</id>
    <published>2018-03-13T12:04:50.000Z</published>
    <updated>2018-03-19T10:37:03.986Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mysql索引介绍</title>
    <link href="http://edgeowner.com/2017/05/06/mysql-index/"/>
    <id>http://edgeowner.com/2017/05/06/mysql-index/</id>
    <published>2017-05-06T11:23:43.000Z</published>
    <updated>2017-05-06T13:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000012773157" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000012773157&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="示例代码" scheme="http://edgeowner.com/categories/%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Code" scheme="http://edgeowner.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://edgeowner.com/2017/05/06/SingletonPattern/"/>
    <id>http://edgeowner.com/2017/05/06/SingletonPattern/</id>
    <published>2017-05-06T10:23:43.000Z</published>
    <updated>2017-05-06T13:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">单例模式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.runoob.com/design-pattern/singleton-pattern.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单例模式&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="示例代码" scheme="http://edgeowner.com/categories/%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Code" scheme="http://edgeowner.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>常用多线程Code示例</title>
    <link href="http://edgeowner.com/2017/05/06/Multi-thread-Programming-Code-Demo/"/>
    <id>http://edgeowner.com/2017/05/06/Multi-thread-Programming-Code-Demo/</id>
    <published>2017-05-06T09:23:43.000Z</published>
    <updated>2017-05-06T13:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用多线程代码示例"><a href="#常用多线程代码示例" class="headerlink" title="常用多线程代码示例"></a>常用多线程代码示例</h3><p>本文主要介绍日常工作中所有使用多线程的场景，将一些多线程的代码使用场景介绍如下，主要以工作中项目中的代码入手为主。介绍ThreadPoolExecutor、FutureTask封装</p><a id="more"></a><hr><h4 id="线程池封装"><a href="#线程池封装" class="headerlink" title="线程池封装"></a>线程池封装</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.saber.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangsunny</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018-04-10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor POOL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> INIT_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> IDEL_TIME = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_QUEUE_SIZE = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据线程名称初始化线程池(Thread方式实现)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Thread thread, String threadName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">            thread.setName(threadName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (POOL == <span class="keyword">null</span>) &#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!POOL.isTerminating() || !POOL.isTerminated()) &#123;</span><br><span class="line">            POOL.execute(thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">"pool is terminating, refuse to execute thread any more"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Runnalbe实现线程池的初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (runnable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">"thread is null, return at once"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (POOL == <span class="keyword">null</span>) &#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!POOL.isTerminating() || !POOL.isTerminated()) &#123;</span><br><span class="line">            POOL.execute(runnable);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">"pool is terminating, refuse to execute thread any more"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"thread pool is destroying"</span>);</span><br><span class="line">        <span class="keyword">if</span> (POOL != <span class="keyword">null</span>) &#123;</span><br><span class="line">            POOL.shutdown();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!POOL.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    log.info(<span class="string">"thread pool is terminate now"</span>);</span><br><span class="line">                    POOL.shutdown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                POOL.shutdown();</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"thread pool is init "</span>);</span><br><span class="line">        <span class="keyword">if</span> (POOL == <span class="keyword">null</span>) &#123;</span><br><span class="line">            POOL = <span class="keyword">new</span> ThreadPoolExecutor(INIT_SIZE, MAX_SIZE,</span><br><span class="line">                    IDEL_TIME, TimeUnit.MINUTES,</span><br><span class="line">                    <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(MAX_QUEUE_SIZE, <span class="keyword">true</span>),</span><br><span class="line">                    <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="FutureTask相关使用"><a href="#FutureTask相关使用" class="headerlink" title="FutureTask相关使用"></a>FutureTask相关使用</h4><p>场景：按照不同的第三方接口返回相同的数据对象结构一致，将4种模糊匹配查询接口结果返回一致，并发访问，以满足4个不同纬度的字段查询人员信息聚合在一个方法查询，最后对结果去重处理。</p><blockquote><p>ConstructFindEmployeeByKeyWordTask封装：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructFindEmployeeByKeyWordTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">List</span>&lt;<span class="title">Employee</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String tenantId;</span><br><span class="line">        <span class="keyword">private</span> String keyWord;</span><br><span class="line">        <span class="keyword">private</span> String methodType;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> dimission;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConstructFindEmployeeByKeyWordTask</span><span class="params">(String tenantId, String keyWord, String methodType, <span class="keyword">boolean</span> dimission)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tenantId = tenantId;</span><br><span class="line">            <span class="keyword">this</span>.keyWord = keyWord;</span><br><span class="line">            <span class="keyword">this</span>.methodType = methodType;</span><br><span class="line">            <span class="keyword">this</span>.dimission = dimission;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            List&lt;Employee&gt; employeeList = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (methodType) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"username"</span>:</span><br><span class="line">                        employeeList = employeeService.searchEmpByUserName(tenantId, keyWord, dimission);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"pinyin"</span>:</span><br><span class="line">                        employeeList = employeeService.searchEmpByPinyin(tenantId, keyWord, dimission);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"misid"</span>:</span><br><span class="line">                        employeeList = employeeService.searchEmpByAccount(tenantId, keyWord, dimission);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"employeeid"</span>:</span><br><span class="line">                        Employee employee = employeeService.queryEmpByJobNumber(tenantId, keyWord);</span><br><span class="line">                        <span class="keyword">if</span> (employee != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            employeeList.add(employee);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Cat.logError(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> employeeList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&gt; conQueryEmployeeByKeyWord方法：</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;EmployeeResultDto&gt; <span class="title">conQueryEmployeeByKeyWord</span><span class="params">(EmployeeQueryDto employeeQueryDto)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        List&lt;EmployeeDto&gt; employeeDtoList = Lists.newArrayList();</span></span><br><span class="line">        String tenantId = employeeQueryDto.getTenantId();</span><br><span class="line">        <span class="keyword">boolean</span> dimission = employeeQueryDto.isDimission();</span><br><span class="line">        String keyWord = employeeQueryDto.getKeyword();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        String mirrorDataDate = employeeQueryDto.getMirrorDate();</span></span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;List&lt;Employee&gt;&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;Future&lt;List&lt;Employee&gt;&gt;&gt;();</span><br><span class="line">        Future future1 = employeeTaskExecutor.submit(<span class="keyword">new</span> ConstructFindEmployeeByKeyWordTask(tenantId, keyWord, EmployeeMethodTypeEnum.USERNAME.getCode(), dimission));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future1) &#123;</span><br><span class="line">            futureList.add(future1);</span><br><span class="line">        &#125;</span><br><span class="line">        Future future2 = employeeTaskExecutor.submit(<span class="keyword">new</span> ConstructFindEmployeeByKeyWordTask(tenantId, keyWord, EmployeeMethodTypeEnum.PINYIN.getCode(), dimission));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future1) &#123;</span><br><span class="line">            futureList.add(future2);</span><br><span class="line">        &#125;</span><br><span class="line">        Future future3 = employeeTaskExecutor.submit(<span class="keyword">new</span> ConstructFindEmployeeByKeyWordTask(tenantId, keyWord, EmployeeMethodTypeEnum.MISID.getCode(), dimission));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future3) &#123;</span><br><span class="line">            futureList.add(future3);</span><br><span class="line">        &#125;</span><br><span class="line">        Future future4 = employeeTaskExecutor.submit(<span class="keyword">new</span> ConstructFindEmployeeByKeyWordTask(tenantId, keyWord, EmployeeMethodTypeEnum.EMPLOYEEID.getCode(), dimission));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future4) &#123;</span><br><span class="line">            futureList.add(future4);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(futureList)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Lists.newLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Employee&gt; allEmployee = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;List&lt;Employee&gt;&gt; _future : futureList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                allEmployee.addAll(_future.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Cat.logError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultToEmployeeDto(allEmployee);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>线程池配置：<br><img src="http://p5vswdxl9.bkt.clouddn.com/1523554008652.jpg" alt="线程池注入"></p><p>XML配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-autowire</span>=<span class="string">"byName"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--employee add by wf--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"employeeTaskExecutor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"allowCoreThreadTimeOut"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keepAliveSeconds"</span> <span class="attr">value</span>=<span class="string">"3600"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corePoolSize"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"50"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"queueCapacity"</span> <span class="attr">value</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"waitForTasksToCompleteOnShutdown"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><hr><h4 id="代码示例地址"><a href="#代码示例地址" class="headerlink" title="代码示例地址"></a>代码示例地址</h4><p>Github地址：<a href=""></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用多线程代码示例&quot;&gt;&lt;a href=&quot;#常用多线程代码示例&quot; class=&quot;headerlink&quot; title=&quot;常用多线程代码示例&quot;&gt;&lt;/a&gt;常用多线程代码示例&lt;/h3&gt;&lt;p&gt;本文主要介绍日常工作中所有使用多线程的场景，将一些多线程的代码使用场景介绍如下，主要以工作中项目中的代码入手为主。介绍ThreadPoolExecutor、FutureTask封装&lt;/p&gt;
    
    </summary>
    
      <category term="示例代码" scheme="http://edgeowner.com/categories/%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Code" scheme="http://edgeowner.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>数据库的锁</title>
    <link href="http://edgeowner.com/2016/11/06/dateSourceLock/"/>
    <id>http://edgeowner.com/2016/11/06/dateSourceLock/</id>
    <published>2016-11-06T12:20:43.000Z</published>
    <updated>2016-11-06T13:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.hollischuang.com/archives/909" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/909&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="并发控制" scheme="http://edgeowner.com/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
      <category term="锁" scheme="http://edgeowner.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>浅析数据库读现象</title>
    <link href="http://edgeowner.com/2016/11/05/dataSourceRead/"/>
    <id>http://edgeowner.com/2016/11/05/dataSourceRead/</id>
    <published>2016-11-05T02:20:28.000Z</published>
    <updated>2016-11-05T02:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.hollischuang.com/archives/900" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/900&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="并发控制" scheme="http://edgeowner.com/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
      <category term="锁" scheme="http://edgeowner.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>事务知识点</title>
    <link href="http://edgeowner.com/2016/10/01/tranaction/"/>
    <id>http://edgeowner.com/2016/10/01/tranaction/</id>
    <published>2016-10-01T11:20:43.000Z</published>
    <updated>2016-10-01T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>&emsp;&emsp;本文主要介绍事务的相关知识点，同时也为后续讲解乐观锁和悲观锁作铺垫，先对以下事务相关的知识点：<code>ACID</code>、<code>事物的常见问题</code>以及<code>事务的隔离级别</code>先做介绍，至于<code>锁</code>后续会有专题详细介绍。<br>事务就是一组原子性的sql，或者一个独立的工作单元，事务可以就Mysql引擎来说的话就是要么全部执行这一组sql语句（CURD组合），要么全部都不执行（比如其中一条语句失败会导致这一组语句全部失败）。<br>事务是并发控制的单元，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位，说白了就是为了保证系统始终处于一个完整且正确的状态。</p><a id="more"></a><hr><h4 id="事务特性：ACID"><a href="#事务特性：ACID" class="headerlink" title="事务特性：ACID"></a>事务特性：ACID</h4><p>事务的ACID特性：</p><h5 id="A：Atomiciy-原子性-："><a href="#A：Atomiciy-原子性-：" class="headerlink" title="A：Atomiciy(原子性)："></a>A：Atomiciy(原子性)：</h5><p>一个事物必须保证其中的操作要么全部执行，要么全部回滚，不可能存在只执行了一部分这种情况出现。简单说就是事务是一个不可分隔的工作单位，事务中的操作要么都发生，要么都不发生；</p><p>事务包含的全部操作是一个不可分割的整体，要么全部执行，要么全部都不执行。</p><h5 id="C：Consistency-一致性-："><a href="#C：Consistency-一致性-：" class="headerlink" title="C：Consistency(一致性)："></a>C：Consistency(一致性)：</h5><p>数据必须保证从一种一致性的状态转换为另一种一致性状态。也就是事务开始到结束的时间段内，事务前后数据的完整性必须保证一致；  </p><p>例如：事务之前A,B两个账户的总和是10万(A:4W,B:6W),现在A转账B2万(A:2W,B:8W),A,B账户总和依旧应该是10万，如果不是10万的话，则事务前后对于账户总和这种资源是不一致的。</p><h5 id="I：Isolation-隔离性-："><a href="#I：Isolation-隔离性-：" class="headerlink" title="I：Isolation(隔离性)："></a>I：Isolation(隔离性)：</h5><p>在一个事物未执行完毕时，通常会保证其他Session无法看到这个事务的执行结果。也就是说多个用户并发访问数据库时，一个用户的事物不能被其他用户的事物所干扰，多个并发事务之间数据要相互隔离。数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的”独立”环境执行；</p><p>主要规定了各个事务之间相互影响的程度，主要用于规定多个事务访问同一数据资源，各个事务对该数据资源访问的行为。</p><h5 id="D：Durability-持久性-："><a href="#D：Durability-持久性-：" class="headerlink" title="D：Durability(持久性)："></a>D：Durability(持久性)：</h5><p>事务一旦commit，则数据就会保存下来，即使提交完之后系统崩溃，数据也不会丢失。</p><p>事务一旦完成，要将数据所做的变更记录下来(冗余存储或多数据网络备份)。</p><hr><h4 id="事务常见问题"><a href="#事务常见问题" class="headerlink" title="事务常见问题"></a>事务常见问题</h4><h5 id="更新丢失-Lost-Update-："><a href="#更新丢失-Lost-Update-：" class="headerlink" title="更新丢失(Lost Update)："></a><code>更新丢失(Lost Update)</code>：</h5><ol><li>场景：假定两个事物有$A$和$B$，事务$A$和事物$B$同时获得相同的数据，然后在各自的事物中修改数据M，事先$A$先提交事物，数据M假如为$M+$，事务$B$后提交事物，数据$M$变成了$M++$，最终结果变成$M++$，覆盖了事物$A$的更新。  </li><li>原因：当多个事务选择同一行操作，并且都是基于最初选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题。类比Github提交冲突。  </li><li>例子：   </li></ol><div class="table-container"><table><thead><tr><th>事物$A$</th><th>事物$B$</th></tr></thead><tbody><tr><td>读取 $X=100$</td><td>读取 $X=100$</td></tr><tr><td>写入 $X=X+100$</td><td></td></tr><tr><td>事物结束 $X = 200$</td><td></td></tr><tr><td></td><td>写入 $X =X+100$</td></tr><tr><td></td><td>事物结束 $X=300$(事物A的数据更新丢失)</td></tr></tbody></table></div><h5 id="脏读-Dirty-Reads-："><a href="#脏读-Dirty-Reads-：" class="headerlink" title="脏读(Dirty Reads)："></a><code>脏读(Dirty Reads)</code>：</h5><ol><li>场景：<strong>允许事物B可以读到事物A修改而未提交的数据</strong>，<strong>可能</strong>会造成脏读（脏读本质就是无效数据，只有当事物$A$回滚，那么事物B读到的数据才为无效的，所以这里只是<strong>可能</strong>造成脏读，当事物$A$不回滚的时候，事物$B$读到的数据就不为脏数据，也就是有效的数据，脏数据会导致以后的操作都会发生错误，一定要避免，不能凭借侥幸，事物$A$不能百分之百保证不回滚，所以<strong>这种隔离级别很少用于实际应用</strong>，并且它的性能也不比其他借笔好）。</li><li>原因：事物B读取了事物$A$已经修改但尚未提交的数据。若事物$A$回滚数据，事物$A$的数据存在不一致性的问题。</li><li>例子：</li></ol><div class="table-container"><table><thead><tr><th>事物$A$</th><th>事物$B$</th></tr></thead><tbody><tr><td>写入 $X=X+100(x=200)$</td><td></td></tr><tr><td></td><td>读取 $X=200$(无效数据，脏读)</td></tr><tr><td>事务回滚 $X=100$</td><td></td></tr><tr><td>事务结束 $X=100$</td><td></td></tr><tr><td></td><td>事务结束</td></tr></tbody></table></div><h5 id="不可重复读-Non-Repeatable-Reads-："><a href="#不可重复读-Non-Repeatable-Reads-：" class="headerlink" title="不可重复读(Non-Repeatable Reads)："></a><code>不可重复读(Non-Repeatable Reads)</code>：</h5><ol><li>场景：不可重复读是指在一个事务范围中$2$次或者多次查询同一数据$M$返回了不同的数据，例如：事务$B$读取某一数据，事务$A$修改了该数据$M$并且提交，事务$B$又读取该数据$M$(可能是再次校验)，在同一个事务$B$中，读取同一个数据$M$的结果集不同。</li><li>原因：事物$B$第一次读取最初数据，第二次读取事物A已经提交的修改或删除数据。导致两次读取数据不一致。不符合事物的隔离性。</li><li>例子：</li></ol><div class="table-container"><table><thead><tr><th>事物$A$</th><th>事物$B$</th></tr></thead><tbody><tr><td>读取 $X=100$</td><td>读取 $X=100$</td></tr><tr><td>写入 $X=X+100$</td><td>读取 $X=100$</td></tr><tr><td>事务结束，$X=200$</td><td></td></tr><tr><td></td><td>读取 $X=200$(在一个事务B中读X的值发生了变化)</td></tr><tr><td></td><td>事物结束</td></tr></tbody></table></div><h5 id="幻读-Phantom-Reads-："><a href="#幻读-Phantom-Reads-：" class="headerlink" title="幻读(Phantom Reads)："></a><code>幻读(Phantom Reads)</code>：</h5><ol><li>当用户读取某一个范围的数据行时，另一个事物又在该范围内查询了新行，当用户再读取该范围的数据行时，会发现会有新的“幻影行”，例如：事物$B$读到某一个数据$M$，事物$A$对数据$M$增加了一行并提交，事物$B$又读数据$M$，发生多出了一行造成的结果不一致(如果行数相同，则是不可重复读)。   </li><li>原因：事物$B$根据相同的条件第二次查询到事物$A$提交的新增数据，两次数据结果集不一致。不符合事物的隔离性。</li><li>例子：在事物$B$里，同一个数据集$M$，读到的条数不一致(新增，删除)。</li></ol><div class="table-container"><table><thead><tr><th>事务$A$</th><th>事务$B$</th></tr></thead><tbody><tr><td></td><td>读取数据集$M$(3行)</td></tr><tr><td>在数据集$M$插入一行(4行)</td><td></td></tr><tr><td>事务结束</td><td></td></tr><tr><td></td><td>读取数据$M$(4行)</td></tr><tr><td></td><td>事务结束</td></tr></tbody></table></div><hr><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>数据库的事物隔离越严格，并发副作用越小，但付出的代价也就越大。因为事务隔离实质上是将事务在一定程度上“串行”进行，这显然与“并发”是矛盾的。实际业务中处理的话，根据自己的业务逻辑，权衡能接受的最大副作用，从而平衡了<strong><em>“隔离” </em></strong>和<strong><em>“并发” </em></strong>的问题。Mysql默认隔离级别是可重复读的。<br>事务的隔离级别通常有四种（RU, RC, RR，Serializable）：</p><div class="table-container"><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读可能性</th><th>不可重复读可能性</th><th>幻读可能性</th><th>加锁读</th></tr></thead><tbody><tr><td>未提交读(Read uncommitted)</td><td>最低级别</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>已提交读(Read committed)</td><td>语句级别</td><td>N</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>可重复读(Repeatable read)</td><td>事务级别</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>可序列化(Serializable)</td><td>最高级别，事务级别</td><td>N</td><td>N</td><td>N</td><td>Y</td></tr></tbody></table></div><hr><h4 id="MySql常用命令"><a href="#MySql常用命令" class="headerlink" title="MySql常用命令"></a>MySql常用命令</h4><h5 id="查询隔离级别"><a href="#查询隔离级别" class="headerlink" title="查询隔离级别"></a>查询隔离级别</h5><p>select @@tx_isolation;</p><h5 id="设置手动提交"><a href="#设置手动提交" class="headerlink" title="设置手动提交"></a>设置手动提交</h5><p>set autocommit=0 ;</p><h5 id="查看当前事务自动提交模式"><a href="#查看当前事务自动提交模式" class="headerlink" title="查看当前事务自动提交模式"></a>查看当前事务自动提交模式</h5><p>select @@autocommit;</p><h5 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h5><p>set tx_isolation = ‘READ-COMMITTED’;</p><h5 id="查询表的状态"><a href="#查询表的状态" class="headerlink" title="查询表的状态"></a>查询表的状态</h5><p>show table status like ‘test1’;</p><h5 id="修改表的存储引擎"><a href="#修改表的存储引擎" class="headerlink" title="修改表的存储引擎"></a>修改表的存储引擎</h5><p>alter table test1 engine = INNODB</p><h5 id="查看是否开启日志"><a href="#查看是否开启日志" class="headerlink" title="查看是否开启日志"></a>查看是否开启日志</h5><p>show variables like ‘log_bin’;</p><h5 id="查看日志状态"><a href="#查看日志状态" class="headerlink" title="查看日志状态"></a>查看日志状态</h5><p>show master status;</p><hr><h4 id="相关技术参考："><a href="#相关技术参考：" class="headerlink" title="相关技术参考："></a>相关技术参考：</h4><p><a href="https://segmentfault.com/a/1190000004437223" target="_blank" rel="noopener">深入浅出事务（1）</a><br><a href="https://segmentfault.com/a/1190000004437275" target="_blank" rel="noopener">深入浅出事务（2）</a><br><a href="https://segmentfault.com/a/1190000004469395" target="_blank" rel="noopener">深入浅出事务（3）</a><br><a href="https://segmentfault.com/a/1190000012773157" target="_blank" rel="noopener">MySQL表锁和行锁机制</a><br><a href="https://juejin.im/post/5ab5e44a6fb9a028c97a013d" target="_blank" rel="noopener">Mysql之锁与事务</a><br><a href="https://segmentfault.com/a/1190000013122242" target="_blank" rel="noopener">数据库 - 事务管理（ACID）、隔离级别、事务传播行为</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本文主要介绍事务的相关知识点，同时也为后续讲解乐观锁和悲观锁作铺垫，先对以下事务相关的知识点：&lt;code&gt;ACID&lt;/code&gt;、&lt;code&gt;事物的常见问题&lt;/code&gt;以及&lt;code&gt;事务的隔离级别&lt;/code&gt;先做介绍，至于&lt;code&gt;锁&lt;/code&gt;后续会有专题详细介绍。&lt;br&gt;事务就是一组原子性的sql，或者一个独立的工作单元，事务可以就Mysql引擎来说的话就是要么全部执行这一组sql语句（CURD组合），要么全部都不执行（比如其中一条语句失败会导致这一组语句全部失败）。&lt;br&gt;事务是并发控制的单元，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位，说白了就是为了保证系统始终处于一个完整且正确的状态。&lt;/p&gt;
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="事务" scheme="http://edgeowner.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁和悲观锁(OCC和PCC)</title>
    <link href="http://edgeowner.com/2016/10/01/optimistic-pessimistic-locking/"/>
    <id>http://edgeowner.com/2016/10/01/optimistic-pessimistic-locking/</id>
    <published>2016-10-01T11:20:43.000Z</published>
    <updated>2016-10-01T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p> &emsp;&emsp;本文在介乐观锁和悲观锁之前请先了解<a href="http://edgeowner.com/2016/10/01/tranaction/">事务相关知识点</a>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。<br>无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。<br>针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。</p><hr><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="乐观锁（Optimistic-Concurrency-Control，OCC）："><a href="#乐观锁（Optimistic-Concurrency-Control，OCC）：" class="headerlink" title="乐观锁（Optimistic Concurrency Control，OCC）："></a>乐观锁（Optimistic Concurrency Control，OCC）：</h4><h5 id="乐观锁的定义："><a href="#乐观锁的定义：" class="headerlink" title="乐观锁的定义："></a>乐观锁的定义：</h5><ul><li>1.在关系数据库管理系统里，乐观锁指的是一种并发控制的方法，又名“乐观锁”(Optimistic Concurrency Control)，缩写“OCC”，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</li><li>2.乐观锁(Optimistic Locking)相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</li><li>3.相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</li></ul><h5 id="乐观锁的流程："><a href="#乐观锁的流程：" class="headerlink" title="乐观锁的流程："></a>乐观锁的流程：</h5><ul><li>1.数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</li></ul><h5 id="悲观锁Demo演示："><a href="#悲观锁Demo演示：" class="headerlink" title="悲观锁Demo演示："></a>悲观锁Demo演示：</h5><ul><li>1.实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。使用版本号实现乐观锁：使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Demo 1.0</span><br><span class="line">1.查询出商品信息</span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">status</span>,<span class="keyword">status</span>,<span class="keyword">version</span>) <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=#&#123;<span class="keyword">id</span>&#125;</span><br><span class="line"><span class="number">2.</span>根据商品信息生成订单</span><br><span class="line"><span class="number">3.</span>修改商品<span class="keyword">status</span>为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> t_goods </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span>=#&#123;<span class="keyword">id</span>&#125; <span class="keyword">and</span> <span class="keyword">version</span>=#&#123;<span class="keyword">version</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="悲观锁的优点和不足："><a href="#悲观锁的优点和不足：" class="headerlink" title="悲观锁的优点和不足："></a>悲观锁的优点和不足：</h5><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p><hr><h4 id="悲观锁（Pessimistic-Concurrency-Control，PCC）："><a href="#悲观锁（Pessimistic-Concurrency-Control，PCC）：" class="headerlink" title="悲观锁（Pessimistic Concurrency Control，PCC）："></a>悲观锁（Pessimistic Concurrency Control，PCC）：</h4><h5 id="悲观锁的定义："><a href="#悲观锁的定义：" class="headerlink" title="悲观锁的定义："></a>悲观锁的定义：</h5><ul><li>1.悲观锁指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）；</li><li>2.关系型数据库里，<strong>悲观并发控制</strong>是一种并发控制的方法。它可以阻止一个事物以影响其他用户的方式来修改数据。如果一个事物执行的操作都某行数据应用了锁，那只有当这个事物把锁释放，其他事物才能执行与该锁冲突的操作。</li></ul><h5 id="悲观锁的流程："><a href="#悲观锁的流程：" class="headerlink" title="悲观锁的流程："></a>悲观锁的流程：</h5><ul><li>1.悲观锁的流程：在对任意记录进行修改前，先尝试为该记录加上<a href="http://www.hollischuang.com/archives/923" target="_blank" rel="noopener">排他锁(exclusive locking)</a>，如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁，期间若有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li></ul><h5 id="悲观锁Demo演示：-1"><a href="#悲观锁Demo演示：-1" class="headerlink" title="悲观锁Demo演示："></a>悲观锁Demo演示：</h5><ul><li><p>1.Mysql InnoDB使用悲观锁：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#Demo 1.0</span><br><span class="line">//0.开始事务</span><br><span class="line"><span class="keyword">begin</span>;/<span class="keyword">begin</span> <span class="keyword">work</span>;/<span class="keyword">start</span> <span class="keyword">transaction</span>; (三者选一就可以)</span><br><span class="line">//1.查询出商品信息</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">//2.根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders (<span class="keyword">id</span>,goods_id) <span class="keyword">values</span> (<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line">//3.修改商品status为2</span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>;</span><br><span class="line">//4.提交事务</span><br><span class="line"><span class="keyword">commit</span>;/<span class="keyword">commit</span> <span class="keyword">work</span>;</span><br></pre></td></tr></table></figure><p>上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。<br><strong><em>使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意 </em></strong>。<br>简单理解下悲观锁：当一个事务锁定了一些数据之后，只有当当前锁提交了事务，释放了锁，其他事务才能获得锁并执行操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事物的成本环境中。</p></li><li><p>2.下面另外一个简单Demo使用方式如下：<br>   首先要关闭MySQL的自动提交：set autocommit = 0;   </p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Demo 2.0</span><br><span class="line"><span class="keyword">begin</span> <span class="comment">--开启事务</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, total, front, <span class="keyword">end</span> <span class="keyword">from</span> price <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> price <span class="keyword">values</span>(?,?,?,?,?)</span><br><span class="line"><span class="keyword">commit</span> <span class="comment">--提交事务</span></span><br></pre></td></tr></table></figure><p>  这里使用<strong>select for update的方式</strong>利用数据库开启了悲观锁，锁定了id=1的这条数据(<strong><em>注意:这里除非是使用了索引会启用行级锁，不然是会使用表锁，将整张表都锁住。 </em></strong>)。之后使用commit提交事务并释放锁，这样下一个线程过来拿到的就是正确的数据。<br>悲观锁一般是用于并发不是很高，并且不允许脏读等情况。但是对数据库资源消耗较大。</p></li></ul><h5 id="悲观锁的优点和不足：-1"><a href="#悲观锁的优点和不足：-1" class="headerlink" title="悲观锁的优点和不足："></a>悲观锁的优点和不足：</h5><p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数.</p><hr><h4 id="相关技术参考："><a href="#相关技术参考：" class="headerlink" title="相关技术参考："></a>相关技术参考：</h4><ol><li><a href="https://juejin.im/post/5962e64c6fb9a06ba14b9cd9" target="_blank" rel="noopener">乐观锁与悲观锁的实际应用</a>(<strong>推荐此文</strong>)</li><li><a href="https://segmentfault.com/a/1190000008935924" target="_blank" rel="noopener">MySQL乐观锁在分布式场景下的实践</a>(<strong>推荐此文</strong>)</li><li><a href="http://www.digpage.com/lock.html" target="_blank" rel="noopener">乐观锁与悲观锁</a></li><li><a href="http://www.hollischuang.com/archives/934" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a></li><li><a href="http://www.importnew.com/21037.html" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a></li><li><a href="https://www.cnblogs.com/deliver/p/5730616.html" target="_blank" rel="noopener">mysql的锁—行锁，表锁，乐观锁，悲观锁</a></li><li><a href="http://www.hollischuang.com/archives/909" target="_blank" rel="noopener">数据库的锁机制</a></li></ol><h4 id="本文代码Demo："><a href="#本文代码Demo：" class="headerlink" title="本文代码Demo："></a>本文代码Demo：</h4><p>Github地址：<a href="git@github.com:edgeowner/saber.git">参见Price相关代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &amp;emsp;&amp;emsp;本文在介乐观锁和悲观锁之前请先了解&lt;a href=&quot;http://edgeowner.com/2016/10/01/tranaction/&quot;&gt;事务相关知识点&lt;/a&gt;乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。&lt;br&gt;
      
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="并发控制" scheme="http://edgeowner.com/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
      <category term="锁" scheme="http://edgeowner.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题目集锦 (1)</title>
    <link href="http://edgeowner.com/2016/06/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E9%9B%86%E9%94%A6/"/>
    <id>http://edgeowner.com/2016/06/01/Java面试题目集锦/</id>
    <published>2016-06-01T12:21:37.000Z</published>
    <updated>2018-03-14T02:35:47.142Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java面试题目汇总" scheme="http://edgeowner.com/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
      <category term="面试题" scheme="http://edgeowner.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(3)</title>
    <link href="http://edgeowner.com/2016/04/26/JVM3/"/>
    <id>http://edgeowner.com/2016/04/26/JVM3/</id>
    <published>2016-04-26T10:00:00.000Z</published>
    <updated>2016-04-27T04:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JVM具体参数和内存区域映射图例"><a href="#JVM具体参数和内存区域映射图例" class="headerlink" title="JVM具体参数和内存区域映射图例"></a>JVM具体参数和内存区域映射图例</h4><p> &emsp;&emsp;此文主要用图例方式描绘了JVM的结构，介绍了JVM内存结构对应的参数名。</p><ul><li>在具体实现上，JVM将需要进行垃圾回收的区域分为3类：新生代（Young Generation）、老年代(Old Generation)、永久代(Permanent Generation)。其中新生代又分为eden和survival（S0、S1），具体结构如下图所示：</li><li><img src="http://p5vswdxl9.bkt.clouddn.com/jvm_and_params_map.png" alt="图示1.0"><a id="more"></a></li><li>简单讲，新生代的eden、新生代的survival、老生代里的对象存活时间依次变长。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>参数名称</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td style="text-align:left">-Xmx</td><td>初始堆大小</td></tr><tr><td style="text-align:left">-Xms</td><td>最大堆大小</td></tr><tr><td style="text-align:left">-Xss</td><td>每个线程的堆栈大小</td></tr><tr><td style="text-align:left">-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td></tr><tr><td style="text-align:left">-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td></tr><tr><td style="text-align:left">-XX:PermSize</td><td>设置持久代(perm gen)初始值</td></tr><tr><td style="text-align:left">-XX:MaxPermSize</td><td>设置持久代最大值</td></tr><tr><td style="text-align:left">-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td></tr><tr><td style="text-align:left">-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td></tr></tbody></table></div><hr><h4 id="JVM内存结构图例"><a href="#JVM内存结构图例" class="headerlink" title="JVM内存结构图例"></a>JVM内存结构图例</h4><p><img src="http://p5vswdxl9.bkt.clouddn.com/JVM_Flow.jpg" alt=""><br>   &emsp;&emsp;方法区和堆是所有<strong>线程共享的内存区域</strong>；而java栈、本地方法栈和程序计数器是运行是<strong>线程私有的内存区域</strong>。</p><ul><li><p>Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p></li><li><p>方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li><li><p>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p></li><li><p>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p></li><li><p>ClassLoader是负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p>Native Interface是负责调用本地接口的。他的作用是调用不同语言的接口给JAVA用，他会在Native Method Stack中记录对应的本地方法，然后调用该方法时就通过Execution Engine加载对应的本地lib。原本多于用一些专业领域，如JAVA驱动，地图制作引擎等，现在关于这种本地方法接口的调用已经被类似于Socket通信，WebService等方式取代。</p></li><li><p>Execution Engine是执行引擎，也叫Interpreter。Class文件被加载后，会把指令和数据信息放入内存中，Execution Engine则负责把这些命令解释给操作系统。</p></li><li><p>Runtime Data Area则是存放数据的，分为五部分：Stack，Heap，Method Area，PC Register，Native Method Stack。几乎所有的关于java内存方面的问题，都是集中在这块。下图是javapapers.com上关于Run-time Data Areas的描述：<img src="http://p5vswdxl9.bkt.clouddn.com/JVM_2.jpg" alt=""></p></li></ul><hr><h4 id="相关技术参考"><a href="#相关技术参考" class="headerlink" title="相关技术参考"></a>相关技术参考</h4><ol><li><a href="https://www.jianshu.com/p/be6f529160b6" target="_blank" rel="noopener">JVM原理分析</a></li><li><a href="https://mp.weixin.qq.com/s/ebg0bT_xBahGV7OAKorBAw" target="_blank" rel="noopener">JVM知识点总览</a></li><li><a href="https://juejin.im/post/5a1cc3596fb9a04506715aad" target="_blank" rel="noopener">JVM系列之GC</a></li><li><a href="https://juejin.im/post/59ad4cd56fb9a02477075780#heading-5" target="_blank" rel="noopener">重读 JVM</a></li><li><a href="https://mijack.github.io/2018/03/18/Garbage-Collection/" target="_blank" rel="noopener">JVM 的内存模型</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JVM具体参数和内存区域映射图例&quot;&gt;&lt;a href=&quot;#JVM具体参数和内存区域映射图例&quot; class=&quot;headerlink&quot; title=&quot;JVM具体参数和内存区域映射图例&quot;&gt;&lt;/a&gt;JVM具体参数和内存区域映射图例&lt;/h4&gt;&lt;p&gt; &amp;emsp;&amp;emsp;此文主要用图例方式描绘了JVM的结构，介绍了JVM内存结构对应的参数名。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在具体实现上，JVM将需要进行垃圾回收的区域分为3类：新生代（Young Generation）、老年代(Old Generation)、永久代(Permanent Generation)。其中新生代又分为eden和survival（S0、S1），具体结构如下图所示：&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://p5vswdxl9.bkt.clouddn.com/jvm_and_params_map.png&quot; alt=&quot;图示1.0&quot;&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(2)</title>
    <link href="http://edgeowner.com/2016/04/24/jvm2/"/>
    <id>http://edgeowner.com/2016/04/24/jvm2/</id>
    <published>2016-04-24T12:00:00.000Z</published>
    <updated>2016-04-24T12:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存结构（运行时数据区）"><a href="#JVM内存结构（运行时数据区）" class="headerlink" title="JVM内存结构（运行时数据区）"></a>JVM内存结构（运行时数据区）</h3><p>该文承接<strong><a href="http://edgeowner.com/2016/04/19/jvm/">JVM内存结构简介(1)</a></strong>博文主要介绍所有<code>线程共享的区域</code>(<strong><em>方法区 </em></strong>和<strong><em>堆</em></strong>))，本文简单介绍剩余JVM的是三个区域：<code>Java栈(Java Stack)</code>、<code>本地方法栈(Native Method Stack)</code>、<code>程序计数器(Program Counter Register)</code>。</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="三、Java虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#三、Java虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="三、Java虚拟机栈(Java Virtual Machine Stacks)"></a>三、Java虚拟机栈(Java Virtual Machine Stacks)</h4><ol><li><strong>作用</strong>：描述的就是Java方法执行的内存模型。每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储<code>局部变量表</code>、<code>操作栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈道出栈的过程。一个方法的执行过程就等同于栈帧进栈出栈的过程。</li><li><strong>特点</strong>：线程私有的，生命周期和线程相同。栈是一个后进先出(<strong>LIFO</strong>)的数据结构，每次方法调用时，一个新的栈帧创建并被压栈到栈顶， 当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。除了栈帧的压栈和出栈，栈不能被直接操作。 在JVM中，若线程请求栈的深度 超过了虚拟机允许的最大深度 ，则会抛出StackOverflowError异常；当栈进行动态扩展，但 无法申请到相应内存空间（此时，线程请求的栈深度未超过虚拟机允许的最大深度）时，则会抛出OutOfMemoryError异常。</li><li><code>局部变量表</code>：存放了编译期间可以知道大小的各种类型变量，它所需要的内存空间大小在编译期间就已经分配，当一个方法被调用时，栈帧进入虚拟机栈，在运行期间，局部变量表大小是不会变化的。</li><li><code>栈帧(Frame)</code>：<strong><em>栈帧只存储指向堆中对象或数组的引用 </em></strong>，包含<code>局部变量数组</code>、<code>返回值</code>、<code>操作数栈</code>、<code>类当前方法运行时常量池引用</code>：  <blockquote><p><code>局部变量数组</code>：包含了方法执行过程中所有变量，包括this引用、所有方法参数、其他局部变量。对于类方法（也就是静态方法），方法参数从下标 0 开始，对于对象方法，位置0保留为 this。（boolean、byte、char、long、short、int、float、double、reference、returnAddress均为局部变量，除了 long 和 double 类型以外，所有的变量类型都占用局部变量数组的一个位置。long 和 double 需要占用局部变量数组两个连续的位置，因为它们是 64 位双精度，其它类型都是 32 位单精度。）<br><code>操作数栈</code>：在执行字节码指令过程中被用到，这种方式类似于原生<strong>CPU寄存器</strong>。大部分JVM字节码把时间花费在操作数栈的操作上：<strong><em>入栈 </em></strong>、<strong><em>出栈 </em></strong> 、<strong><em>复制 </em></strong> 、<strong><em>交换 </em></strong>、<strong><em>产生消费变量 </em></strong>的操作。因此，局部变量数组和操作数栈之间的交换变量指令操作通过字节码频繁执行。比如，一个简单的变量初始化语句将产生两条跟操作数栈交互的字节码。</p><p>关于局部变量数组、操作数栈和运行时常量池之间交互的详细信息，可以在类文件结构部分找到。</p></blockquote></li></ol><hr><h4 id="四、本地方法栈-Native-Method-Stack"><a href="#四、本地方法栈-Native-Method-Stack" class="headerlink" title="四、本地方法栈(Native Method Stack)"></a>四、本地方法栈(Native Method Stack)</h4><ol><li><strong>作用</strong>：Java虚拟机在实现时，可以根据自身需求，确定是否实现本地方法栈。在实现上，JVM可能会使用到传统的栈（通常称之为“C Stacks”）来支持 native 方法（指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈。当JVM支持本地方法栈时，这个栈会在线程创建时按照线程分配。 在JVM中，本地方法栈可能发生的异常情况也分为Stack OverflowError和OutOfMemoryError异常，出错原因和虚拟机栈相似，此处不再赘述。</li><li><strong>特点</strong>：Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。本地方法栈则是为虚拟机使用到的Native方法服务.</li></ol><hr><h4 id="五、程序计数器-Program-Counter-Register"><a href="#五、程序计数器-Program-Counter-Register" class="headerlink" title="五、程序计数器(Program Counter Register)"></a>五、程序计数器(Program Counter Register)</h4><ul><li>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li><strong><em>在任意时刻，一个Java虚拟机线程只会执行一个方法，而 PC Java 虚拟机允许多条线程同时执行。因此，每一条 Java虚拟机线程都有自己的 PC 寄存器 ，他们是相互独立的。每一条 Java虚拟机线程都有自己的PC 寄存器，他们是相互独立的。 </em></strong></li><li>我们称正在被线程执行的方法称为该线程的当前方法（Current Method）。如果这个方法不是 native 的，那 PC 寄存器就保存 Java 虚拟机正在执行的字节码指令的地址，如果该方法是 native 的，那 PC 寄存器的值是 undefined。</li><li>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</li><li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;a href=&quot;#JVM内存结构（运行时数据区）&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;/a&gt;JVM内存结构（运行时数据区）&lt;/h3&gt;&lt;p&gt;该文承接&lt;strong&gt;&lt;a href=&quot;http://edgeowner.com/2016/04/19/jvm/&quot;&gt;JVM内存结构简介(1)&lt;/a&gt;&lt;/strong&gt;博文主要介绍所有&lt;code&gt;线程共享的区域&lt;/code&gt;(&lt;strong&gt;&lt;em&gt;方法区 &lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;堆&lt;/em&gt;&lt;/strong&gt;))，本文简单介绍剩余JVM的是三个区域：&lt;code&gt;Java栈(Java Stack)&lt;/code&gt;、&lt;code&gt;本地方法栈(Native Method Stack)&lt;/code&gt;、&lt;code&gt;程序计数器(Program Counter Register)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor 参数详解</title>
    <link href="http://edgeowner.com/2016/04/21/ThreadPoolExecutor/"/>
    <id>http://edgeowner.com/2016/04/21/ThreadPoolExecutor/</id>
    <published>2016-04-21T01:15:31.000Z</published>
    <updated>2016-04-21T12:17:23.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java Multi-thread Programming" scheme="http://edgeowner.com/categories/Java-Multi-thread-Programming/"/>
    
    
      <category term="多线程" scheme="http://edgeowner.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://edgeowner.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor 参数详解</title>
    <link href="http://edgeowner.com/2016/04/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://edgeowner.com/2016/04/20/Java多线程/</id>
    <published>2016-04-20T01:15:31.000Z</published>
    <updated>2016-04-20T12:17:23.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java Multi-thread Programming" scheme="http://edgeowner.com/categories/Java-Multi-thread-Programming/"/>
    
    
      <category term="多线程" scheme="http://edgeowner.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(1)</title>
    <link href="http://edgeowner.com/2016/04/19/jvm/"/>
    <id>http://edgeowner.com/2016/04/19/jvm/</id>
    <published>2016-04-19T10:35:25.000Z</published>
    <updated>2016-04-19T12:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存结构（运行时数据区）"><a href="#JVM内存结构（运行时数据区）" class="headerlink" title="JVM内存结构（运行时数据区）"></a>JVM内存结构（运行时数据区）</h3><p>JVM内存结构指得是：运行时数据区（Runtime Data Area），由 <strong><em>方法区(Method Area) </em></strong>、<strong><em>堆(Heap) </em></strong>、<strong><em>Java栈(Java Stack) </em></strong>、<strong><em>本地方法栈(Native Method Stack)</em></strong>、<strong><em>程序计数器(Program Counter Register)</em></strong>。<br><img src="http://p5vswdxl9.bkt.clouddn.com/JVMRuntime" alt=""></p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="一、方法区-Method-Area"><a href="#一、方法区-Method-Area" class="headerlink" title="一、方法区(Method Area)"></a>一、方法区(Method Area)</h4><ol><li><strong>作用</strong>： 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。此区域内存回收目标主要针对常量池回收和对类型的卸载回收。 </li><li><strong>特点</strong>：线程共享 。</li><li><strong>永久代的疑问(PerGen)</strong>：该内存区域一般被称为”_<strong>永久代(Permanent Generation)</strong>_ “，二者并不等价，设计之初就把GC分代收集扩展至方法区，或者说使用永久代实现方法区而已。</li><li><strong>运行时常量池</strong>：方法区的一部分，存放<strong><em>编译期</em></strong>生成的<strong>各种字面量</strong>(“zdy”,”123”等)和 <strong>符号引用</strong> 。编译器和运行期的intern()都可以将常量放入池中。受方法区限制，常量池无法申请到内存时会抛出OutOfMemoryError异常。运行时常量池具有动态性，并非只有Class文件中的内容才能进入运行时常量池，<strong><em>运行期间</em></strong>也能将新的常量放入池中。如String.intern（）方法。</li><li><strong>方法区储存类的信息</strong>： <ol><li><code>Classloader引用</code>；</li><li><code>运行时常量池</code>：数值型常量、字段引用、方法引用、属   性；  </li><li><code>字段数据</code>：针对每个字段的信息、字段名、类型、修饰符、属性；</li><li><code>方法数据</code>：每个方法、方法名、返回值类型、参数类型、修饰符、属性；</li><li><code>方法代码</code>：每个方法、字节码、操作数栈大小、局部变量大小、局部变量表、异常表、每个异常处理器、开始点、结束点、异常处理代码的程序计数器偏移量、被捕获异常类对应的常量池下标；</li></ol></li></ol><ul><li><strong><em> 字面量(literal) </em></strong>：由字母，数字等构成的字符串或者数值，用于表达源代码中一个固定值的表示法(notation)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。</li><li><strong><em> 符号引用 </em></strong>：简单地说就是，符号引用存在class文件中的常量池，包括类和接口的全限定名、字段的名称和描述符以及方法的名称和描述符。jvm加载class的时候就可以凭着这三者进行动态连接，得到具体的内存地址。占用的数据结构在常量池项目类型有，例如类或接口的符号引用结构为u1的tag和u2的name_index。</li></ul><hr><h4 id="二、堆-Heap"><a href="#二、堆-Heap" class="headerlink" title="二、堆(Heap)"></a>二、堆(Heap)</h4><ol><li><strong> 作用 </strong>：被所有线程运行时共享的内存区域，JVM启动之后，存放对象实例和数组，内部会划出多个线程私有的分配缓冲区(Thread Location Allocation Buffer ,<strong>TLAB</strong>)。该存储区域物理上可以是不连续空间，但是逻辑上一定要连续。</li><li><strong> 特点 </strong>：是GC管理的主要区域，由于GC（垃圾收集器）是采用分代收集算法,根据对象存活率，堆还可以分为<strong>新生代</strong>、<strong>老年代</strong>、<strong>永久代</strong>。</li><li><p><strong> 分类 </strong>：</p><blockquote><p>_<strong>新生代(Young Generation)</strong>_ ：方法中去new一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象。 每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后清理Eden和刚才用过的Survivor空间。<strong><em> HotSpot虚拟机默认Eden和Survivor的大小比例是8:1 </em></strong>，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。 98%的对象可回收只是一般场景下的数据，没办法保证每次回收都只有不多于10%的对象存活，当Survivor不够用时，需要依赖于老年代进行分配担保，所以<strong><em> 大对象 </em></strong>直接进入老年代。同时长期存活的对象进入老年代（虚拟机给每个对象定义一个年龄计数器）。<br><code>年轻代内存又被分成三部分</code>：  </p><ol><li><code>Eden空间</code>：对象优先分配在Eden区，若Eden区无足够的空间，虚拟机执行一次Minor GC。对象被创建时首先放到这个区域，进行垃圾回收后，不能被回收的对象被放到空的Survivor区域。</li><li><code>Survivor Space幸存者区</code>：用于保存在Eden Space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两类，分别为<strong><em>To Suvivor </em></strong> 和 <strong><em>From Suvivor</em></strong>两个区域，这两个区域空间大小是一样的执行：<br>   &emsp;&emsp;a.<code>From Survivor空间</code>：<br>   &emsp;&emsp;b.<code>To Survivor空间</code> ：      </li><li><code>执行回收的内存运行</code>： 执行垃圾回收时Eden区域不能被回收的对象被放入到空的Suvivor(也就是<strong>To Survivor</strong>，同时Eden区域的内存会在垃圾回收的过程中全部释放)，另一个Survivor(即From Survivor)里不能被回收的对象也会被放入到Survivor(即To Survivor)，然后To Survivor和 From Survivor的标记会互换，始终保证一个Survivor是空的。 </li></ol><p>_<strong>老年代(Old Generation)</strong>_ ：<strong> 老年代空间大小&emsp;=&emsp;堆空间大小&emsp;—&emsp;年轻代大空间大小 </strong>   </p></blockquote></li><li><p><strong> 年轻代的垃圾回收 </strong>：<strong><em>Eden Space(伊甸园) </em></strong>和<strong><em>Suvivor Space </em></strong>都属于新生代，新生代中执行垃圾回收被称为Minor GC(由于是对新生代进行垃圾回收，所以被称为Young GC)，每次Young GC 后留下来的对象age +1。</p><blockquote><p>_<strong> Eden:From:TO =8:1:1</strong>_<br> 由于新生代中90%的对象都是”朝生夕死”，采用复制算法是比较合理的，首先只移动了存活下来的对象(比较少数),其次内存在移动到To区域后是有顺序的，不存在内存碎片。值得一提的是，假如在一次Minor GC时,<code>Eden中存活的对象</code>+<code>From中存活的对象</code>&gt;<code>To的剩余空间</code>，则会通过担保机制将对象直接转移到Old Gen ,如果Old Gen的内存空间也不够，则进行一次Full GC .当<strong><em> 对象的年龄到达15岁时会转移到Old Gen(可通过参数配置，一般不建议更改) </em></strong></p></blockquote></li><li><p><strong> 使用方式 </strong>：Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。<strong><em> 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 </em></strong></p></li><li><code>对象分配规则</code>：<br> <code>1.对象优先分配在Eden区</code>：若Eden区没有足够的空间时，虚拟机执行一次Minor GC；<br> <code>2.大对象(大对象是指需要大量连续内存空间的对象)直接进入老年代</code>：这样做目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝(新生代采用 <strong><em>复制算法 </em></strong> 收集内存)；<br> <code>3.长期存活的对象进入老年代</code>：虚拟机为每个对象定义一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象年龄加 1，直到达到阀值，对象进入老年区；<br> <code>4.动态判断对象的年龄</code>：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代；<br> <code>5.空间分配担保</code>：每次每次进行Minor GC时，JVM会计算Survivor区移至<strong>老年区的对象</strong>的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC，如果false则进行Full GC；    </li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;a href=&quot;#JVM内存结构（运行时数据区）&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;/a&gt;JVM内存结构（运行时数据区）&lt;/h3&gt;&lt;p&gt;JVM内存结构指得是：运行时数据区（Runtime Data Area），由 &lt;strong&gt;&lt;em&gt;方法区(Method Area) &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;堆(Heap) &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;Java栈(Java Stack) &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;本地方法栈(Native Method Stack)&lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;程序计数器(Program Counter Register)&lt;/em&gt;&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;http://p5vswdxl9.bkt.clouddn.com/JVMRuntime&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaCore（1）</title>
    <link href="http://edgeowner.com/2015/04/13/Java-Core/"/>
    <id>http://edgeowner.com/2015/04/13/Java-Core/</id>
    <published>2015-04-13T11:06:43.000Z</published>
    <updated>2015-04-14T12:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java核心"><a href="#Java核心" class="headerlink" title="Java核心"></a>Java核心</h2><h4 id="Java基本语法："><a href="#Java基本语法：" class="headerlink" title="Java基本语法："></a>Java基本语法：</h4><h4 id="Java类和对象："><a href="#Java类和对象：" class="headerlink" title="Java类和对象："></a>Java类和对象：</h4><h4 id="Java集合："><a href="#Java集合：" class="headerlink" title="Java集合："></a>Java集合：</h4><h4 id="Java泛型："><a href="#Java泛型：" class="headerlink" title="Java泛型："></a>Java泛型：</h4><h4 id="Java注解："><a href="#Java注解：" class="headerlink" title="Java注解："></a>Java注解：</h4><h4 id="Java反射："><a href="#Java反射：" class="headerlink" title="Java反射："></a>Java反射：</h4><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java核心&quot;&gt;&lt;a href=&quot;#Java核心&quot; class=&quot;headerlink&quot; title=&quot;Java核心&quot;&gt;&lt;/a&gt;Java核心&lt;/h2&gt;&lt;h4 id=&quot;Java基本语法：&quot;&gt;&lt;a href=&quot;#Java基本语法：&quot; class=&quot;headerlink&quot; title=&quot;Java基本语法：&quot;&gt;&lt;/a&gt;Java基本语法：&lt;/h4&gt;&lt;h4 id=&quot;Java类和对象：&quot;&gt;&lt;a href=&quot;#Java类和对象：&quot; class=&quot;headerlink&quot; title=&quot;Java类和对象：&quot;&gt;&lt;/a&gt;Java类和对象：&lt;/h4&gt;&lt;h4 id=&quot;Java集合：&quot;&gt;&lt;a href=&quot;#Java集合：&quot; class=&quot;headerlink&quot; title=&quot;Java集合：&quot;&gt;&lt;/a&gt;Java集合：&lt;/h4&gt;&lt;h4 id=&quot;Java泛型：&quot;&gt;&lt;a href=&quot;#Java泛型：&quot; class=&quot;headerlink&quot; title=&quot;Java泛型：&quot;&gt;&lt;/a&gt;Java泛型：&lt;/h4&gt;&lt;h4 id=&quot;Java注解：&quot;&gt;&lt;a href=&quot;#Java注解：&quot; class=&quot;headerlink&quot; title=&quot;Java注解：&quot;&gt;&lt;/a&gt;Java注解：&lt;/h4&gt;&lt;h4 id=&quot;Java反射：&quot;&gt;&lt;a href=&quot;#Java反射：&quot; class=&quot;headerlink&quot; title=&quot;Java反射：&quot;&gt;&lt;/a&gt;Java反射：&lt;/h4&gt;
    
    </summary>
    
      <category term="Java" scheme="http://edgeowner.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://edgeowner.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>归并排序（Merge Sort）</title>
    <link href="http://edgeowner.com/2015/03/28/mergeSort/"/>
    <id>http://edgeowner.com/2015/03/28/mergeSort/</id>
    <published>2015-03-28T11:35:31.000Z</published>
    <updated>2015-03-28T12:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>归并过程为：比较$a[i]$和$b[j]$的大小，若$a[i]≤b[j]$，则将第一个有序表中的元素$a[i]$复制到$r[k]$中，并令$i$和$k$分别加上$1$；否则将第二个有序表中的元素$b[j]$复制到$r[k]$中，并令$j$和$k$分别加上$1$，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到$r$中从下标$k$到下标$t$的单元。归并排序的算法我们通常用递归实现，先把待排序区间$[s,t]$以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间$[s,t]$。</p><hr><a id="more"></a><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>Selection Sort、Bubble Sort、Insertion Sort is $O(n^2)$ in average case , Merge Sort $O(n log(n))$ in worst case.</p><ol><li>In this sorting algorithm we use the idea of divide and conquer. We divide the array into two parts, sort them and then merge them to get the elements in ascending or descending order. Merge sorting is done recursively.</li><li>We take an array and keep dividing from the middle till we get only one element in each halves(sub-array).</li><li>The we sort the sub-arrays and join (merge) them back to get the final sorted array.</li></ol><blockquote><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤3直到某一指针超出序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol></blockquote><p><strong>总结</strong>：</p><ul><li>将两个已排好序的数组合并成一个有序的数组,称之为归并排序；</li><li>步骤：遍历两个数组，比较它们的值。谁比较小，谁先放入大数组中，直到数组遍历完成；</li></ul><p>算法动态展示</p><ol><li><a href="https://www.youtube.com/watch?v=7zuGmKfUt7s&amp;t=15s" target="_blank" rel="noopener">YouTube视频源地址</a> ;</li><li><a href="https://www.youtube.com/watch?v=e5ik2UGjHBk" target="_blank" rel="noopener">Merge Sort - step by step guide</a>;<br><strong><em>In this video beg and end are pointing at array index not the value at the array index.﻿ </em></strong></li><li><a href="https://www.youtube.com/watch?v=qdv3i6X0PiQ" target="_blank" rel="noopener">开课老师视频源</a>; </li><li><a href="https://www.youtube.com/watch?v=TzeBrDU-JaY&amp;t=319s" target="_blank" rel="noopener">MycodeSchool</a> </li><li><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/mergeSort.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></li></ol><hr><h4 id="代码实现方式"><a href="#代码实现方式" class="headerlink" title="代码实现方式"></a>代码实现方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 归并排序</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arrs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (arrs == <span class="keyword">null</span> || arrs.length == <span class="number">0</span> || arrs.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mergeSort(arrs, <span class="number">0</span>, arrs.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 归并排序核心部分(递归调用)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arrs, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果只有一个元素就不用排序</span></span><br><span class="line">      <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//取消中间数，进行拆分</span></span><br><span class="line">          <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">          <span class="comment">//左边的数不断进行拆分</span></span><br><span class="line">          mergeSort(arrs, left, middle);</span><br><span class="line">          <span class="comment">//右边的数不断进行拆分</span></span><br><span class="line">          mergeSort(arrs, middle + <span class="number">1</span>, right);</span><br><span class="line">          <span class="comment">//合并</span></span><br><span class="line">          merge(arrs, left, middle + <span class="number">1</span>, right);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 合并数组</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> left   指向数组第一个元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> middle 指向数组分隔的元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> right  指向数组最后的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arrs, <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//左边的数组大小</span></span><br><span class="line">      <span class="keyword">int</span>[] leftArrs = <span class="keyword">new</span> <span class="keyword">int</span>[middle - left];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//右边的数组大小</span></span><br><span class="line">      <span class="keyword">int</span>[] rightArrs = <span class="keyword">new</span> <span class="keyword">int</span>[right - middle + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//往这两个数组填充数据</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; middle; i++) &#123;</span><br><span class="line">          leftArrs[i - left] = arrs[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = middle; i &lt;= right; i++) &#123;</span><br><span class="line">          rightArrs[i - middle] = arrs[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//arrs数组的第一个元素</span></span><br><span class="line">      <span class="keyword">int</span> k = left;</span><br><span class="line">      <span class="comment">//比较两个数组的值，哪个小，就往数组上放</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; leftArrs.length &amp;&amp; j &lt; rightArrs.length) &#123;</span><br><span class="line">          <span class="comment">//谁比较小，谁将元素放入大数组中，移动指针，继续比较下一个</span></span><br><span class="line">          <span class="keyword">if</span> (leftArrs[i] &lt; rightArrs[j]) &#123;</span><br><span class="line">              arrs[k] = leftArrs[i];</span><br><span class="line">              i++;</span><br><span class="line">              k++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              arrs[k] = rightArrs[j];</span><br><span class="line">              j++;</span><br><span class="line">              k++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; leftArrs.length) &#123;</span><br><span class="line">          arrs[k] = leftArrs[i];</span><br><span class="line">          i++;</span><br><span class="line">          k++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果右边的数组还没比较晚，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">      <span class="keyword">while</span> (j &lt; rightArrs.length) &#123;</span><br><span class="line">          arrs[k] = rightArrs[j];</span><br><span class="line">          k++;</span><br><span class="line">          j++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>参考地址：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484058&amp;idx=1&amp;sn=432c2dd8e4bda662ce066c09f8e22bda&amp;chksm=ebd7439bdca0ca8ded40d0f431db411928936db9b4b5f5595027c8acd2efdef5ba35348641d2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">归并排序</a><br>Demo代码地址：<a href="git@github.com:edgeowner/JavaCoreDemo.git">Github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h3&gt;&lt;p&gt;归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。&lt;/p&gt;
&lt;p&gt;归并过程为：比较$a[i]$和$b[j]$的大小，若$a[i]≤b[j]$，则将第一个有序表中的元素$a[i]$复制到$r[k]$中，并令$i$和$k$分别加上$1$；否则将第二个有序表中的元素$b[j]$复制到$r[k]$中，并令$j$和$k$分别加上$1$，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到$r$中从下标$k$到下标$t$的单元。归并排序的算法我们通常用递归实现，先把待排序区间$[s,t]$以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间$[s,t]$。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://edgeowner.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://edgeowner.com/tags/Algorithms/"/>
    
      <category term="Sort" scheme="http://edgeowner.com/tags/Sort/"/>
    
  </entry>
  
</feed>
